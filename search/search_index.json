{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BlackBox","text":"<p>BlackBox is a Property Based Testing framework.</p> <p>It leverages randomness to prove the correctness of your code.</p> <p>It's the main testing framework for the Innmind ecosystem.</p> <p>It allows to:</p> <ul> <li>write tests (1)</li> <li>write proofs</li> <li>write properties</li> <li>generate random data</li> </ul> <ol> <li>Like any other PHP testing framework</li> </ol> <p>Its Functional<sup>1</sup> design also allows you to use it for your own scenarii.</p> Sneak peek tests.php<pre><code>use Innmind\\BlackBox\\{\n    Application\n    Set,\n    Runner\\Assert,\n};\n\nApplication::new([])\n    -&gt;scenariiPerProof(1_000)\n    -&gt;tryToProve(static function() {\n        yield proof(\n            'Add is commutative',\n            given(\n                Set::integers(),\n                Set::integers(),\n            ),\n            static function(Assert $assert, int $a, int $b) {\n                $assert-&gt;same(\n                    add($a, $b),\n                    add($b, $a),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <ol> <li> <p>As in Functional Programming\u00a0\u21a9</p> </li> </ol>"},{"location":"config/","title":"Configuring the test runner","text":""},{"location":"config/#changing-the-number-of-scenarii-for-each-proof","title":"Changing the number of scenarii for each proof","text":"<p>By default BlackBox will generate <code>100</code> scenarii per proof. You may want to increase this number if you want it to be quicker to find a failing scenario. Or you may want to decrease it if you write functional tests as it would take too much time.</p> <p>To do so:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new([])\n    -&gt;scenariiPerProof(1_000)\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#disabling-the-shrinking","title":"Disabling the shrinking","text":"<p>The shrinking is the process by which BlackBox will try to find the smallest input that make a scenario fail. You may want to disable it in some cases like writing functional tests as it may take too much time.</p> <p>To do so:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new([])\n    -&gt;disableShrinking()\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#code-coverage","title":"Code coverage","text":"<p>You can record the code covered by your proofs and dump the report to a file like this:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n    Runner\\CodeCoverage,\n};\n\nApplication::new([])\n    -&gt;codeCoverage(\n        CodeCoverage::of('src/')\n            -&gt;dumpTo('coverage.clover'),\n    )\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#changing-the-way-the-framework-outputs-the-results","title":"Changing the way the framework outputs the results","text":"<p>By default the framework outputs any data as soon as possible to keep the usage of memory low but this means rewinding the output to find a failure. If you want to change the output you need to implement the interface <code>Innmind\\BlackBox\\Runner\\Printer</code> and declare it liek this:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new([])\n    -&gt;usePrinter(new YourPrinter())\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#disable-global-functions","title":"Disable global functions","text":"<p>By default the framework exposes the <code>proof</code>, <code>test</code>, <code>property</code>, <code>properties</code> and <code>given</code> global functions but if you don't want them to avoid collisions with your own methods you can use the namespaced functions (available in the <code>Innmind\\BlackBox\\Runner</code> namespace).</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new([])\n    -&gt;disableGlobalFunctions()\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#disable-github-action-output","title":"Disable GitHub Action output","text":"<p>When it detects it's run inside a GitHub Action the framework groups each proof output to make the output more compact for large suites. It also adds annotations to quickly jump to each failing proof.</p> <p>You can disable such behaviour like this:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n    Runner\\Printer\\Standard,\n};\n\nApplication::new([])\n    -&gt;usePrinter(Standard::new()-&gt;disableGitHubOutput())\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"config/#allow-proofs-to-not-make-any-assertions","title":"Allow proofs to not make any assertions","text":"<p>By default BlackBox will fail a proof when a scenario did not make any assertion. This is to make sure proof are correctly written and none that make no assertions goes unnoticed.</p> <p>However if your style of making assertions may not always lead to a proof making one, then you can disable this feature this way:</p> <pre><code>use Innmind\\BlackBox\\Application;\n\nApplication::new([])\n    -&gt;allowProofsToNotMakeAnyAssertions()\n    -&gt;tryToProve(static function() {\n        yield proof(\n            'Some proof',\n            given(Set::of('some input')),\n            static function($assert, $input) {\n                try {\n                    doSomething($input);\n                    $assert-&gt;fail('It should throw');\n                } catch (\\Exception $e) {\n                    // expected behaviour\n                }\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre>"},{"location":"phpunit/","title":"PHPUnit","text":"<p>If you don't yet feel confident completely switching to a different test runner, BlackBox can also be used with PHPUnit.</p>"},{"location":"phpunit/#as-a-data-provider","title":"As a data provider","text":"MyTestCase.php<pre><code>use Innmind\\BlackBox\\{\n    PHPUnit\\BlackBox,\n    Set,\n};\nuse PHPUnit\\Framework\\{\n    TestCase,\n    Attributes\\DataProvider,\n};\n\nfinal class MyTestCase extends TestCase\n{\n    use BlackBox;\n\n    #[DataProvider('values')]\n    public function testAddIsCommutative(int $a, int $b)\n    {\n        $this-&gt;assertSame(\n            add($a, $b),\n            add($b, $a),\n        );\n    }\n\n    public static function values(): iterable\n    {\n        return self::forAll(\n            Set::integers(),\n            Set::integers(),\n        )-&gt;asDataProvider();\n    }\n}\n</code></pre> <p>This will generate <code>100</code> scenarii for the test.</p> <p>By using BlackBox as a data provider you enter into some limitations:</p> <ul> <li>you won't benefit from the shrinking mechanism</li> <li>you may run out of memory (since PHPUnit keep in memory all scenarii data)</li> </ul>"},{"location":"phpunit/#like-blackbox","title":"Like BlackBox","text":"<p>The previous example becomes:</p> MyTestCase.php<pre><code>use Innmind\\BlackBox\\{\n    PHPUnit\\BlackBox,\n    Set,\n};\nuse PHPUnit\\Framework\\TestCase;\n\nfinal class MyTestCase extends TestCase\n{\n    use BlackBox;\n\n    public function testAddIsCommutative(int $a, int $b)\n    {\n        $this\n            -&gt;forAll(\n                Set::integers(),\n                Set::integers(),\n            )\n            -&gt;then(function(int $a, int $b) {\n                $this-&gt;assertSame(\n                    add($a, $b),\n                    add($b, $a),\n                );\n            });\n    }\n}\n</code></pre> <p>Here you need to use the PHPUnit methods to write your assertions. BlackBox only deals with generating and shrinking data.</p> <p>Like this BlackBox is able to shrink a failing scenario. But to see the generated input values you need to add an extension.</p> phpunit.xml.dist<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;phpunit\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    colors=\"true\"\n    bootstrap=\"vendor/autoload.php\"\n    xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/10.1/phpunit.xsd\"&gt;\n  &lt;extensions&gt;\n    &lt;bootstrap class=\"Innmind\\BlackBox\\PHPUnit\\Extension\"&gt;\n    &lt;/bootstrap&gt;\n  &lt;/extensions&gt;\n  &lt;testsuites&gt;\n    &lt;testsuite name=\"Test suite\"&gt;\n      &lt;directory&gt;./tests&lt;/directory&gt;\n    &lt;/testsuite&gt;\n  &lt;/testsuites&gt;\n  &lt;source&gt;\n    &lt;include&gt;\n      &lt;directory&gt;.&lt;/directory&gt;\n    &lt;/include&gt;\n  &lt;/source&gt;\n&lt;/phpunit&gt;\n</code></pre>"},{"location":"phpunit/#running-your-tests-via-blackbox","title":"Running your tests via BlackBox","text":"<p>If you wish to migrate to BlackBox but don't want to rewrite all your existing tests you can run them directly via BlackBox.</p> <p>The first step is to prefix the <code>PHPUnit\\Framework\\TestCase</code> class with <code>Innmind\\BlackBox\\</code>.</p> <p>The second step is to load the tests like this:</p> <pre><code>use Innmind\\BlackBox\\{\n    Application,\n    PHPUnit\\Load,\n};\n\nApplication::new()\n    -&gt;tryToProve(function() {\n        yield from Load::testsAt('path/to/your/tests');\n    })\n    -&gt;exit();\n</code></pre> <p>If you want to take a look at a migration you can look at BlackBox's own PHPUnit tests that are now run via BlackBox itself.</p> <p>Running BlackBox's PHPUnit tests via BlackBox increase execution speed by 35% (from ~7.1s down to ~4.6s) on a MackBook Pro M1 Max.</p>"},{"location":"phpunit/#display-all-scenarii","title":"Display all scenarii","text":"<p>If you've declared your proofs inside a PHPUnit test method, when run directly via BlackBox it will show up as a single scenario. On top of that you can't see the shrinking mechanism.</p> <p>You can better integrate these proofs inside BlackBox via these changes:</p> MyTestCase.php<pre><code>use Innmind\\BlackBox\\{\n    PHPUnit\\BlackBox,\n    Set,\n};\nuse PHPUnit\\Framework\\TestCase;\n\nfinal class MyTestCase extends TestCase\n{\n    use BlackBox;\n\n    public function testAddIsCommutative(int $a, int $b): BlackBox\\Proof\n    {\n        return $this\n            -&gt;forAll(\n                Set::integers(),\n                Set::integers(),\n            )\n            -&gt;prove(function(int $a, int $b) {\n                $this-&gt;assertSame(\n                    add($a, $b),\n                    add($b, $a),\n                );\n            });\n    }\n}\n</code></pre> <p>Instead of calling <code>$this-&gt;forAll()-&gt;then()</code> you call <code>$this-&gt;forAll()-&gt;prove()</code> and return the object.</p> <p>Now each scenario will be correctly displayed and the number of scenarii configured in <code>Innmind\\BlackBox\\Application</code> is correctly respected (no need to use the <code>BLACKBOX_SET_SIZE</code> environment variable anymore).</p> Note <p>Note that the calls to <code>-&gt;take()</code> and <code>-&gt;disableShrinking()</code> won't do anything in this context as it uses the global configuration.</p>"},{"location":"phpunit/#feature-coverage","title":"Feature coverage","text":"<p>PHPUnit is a very large testing framework with lots of features. BlackBox doesn't support all its features when running your tests.</p> <p>Supported features:</p> <ul> <li>test <code>setUp()</code>/<code>tearDown()</code></li> <li>assertions that have a correspondance in BlackBox</li> <li>data providers declared with an attribute</li> <li>groups declared with an attribute (the name must have a correspondance in <code>Innmind\\BlackBox\\Tag</code>)</li> </ul> <p>Some important features that are not supported:</p> <ul> <li>mocks</li> <li>classes <code>setUpBeforeClass()</code>/<code>tearDownAfterClass()</code></li> <li>assertions that don't have a correspondance in BlackBox (such as files assertions)</li> </ul>"},{"location":"sets/","title":"<code>Set</code>s","text":"<p>So far you've seen hardcoded <code>Set</code>s via <code>Set::of()</code> and integers one via <code>Set::integers()</code>. But there are much more.</p> Tip <p>You can find more on Packagist.</p>"},{"location":"sets/#common-methods","title":"Common methods","text":""},{"location":"sets/#map","title":"Map","text":"<p>For all <code>Set</code> objects you can transform the generated values with a function of your own.</p> <p>Let's say the code you want to prove needs a <code>Password</code> object. You can wrap strings in your object like this:</p> <pre><code>use Innmind\\BlackBox\\Set;\n\n$set = Set::strings()\n    -&gt;map(static fn(string $string) =&gt; new Password($string));\n</code></pre> <p>Now if you use <code>$set</code> in a proof it will generate instances of <code>Password</code> with a random string inside it.</p>"},{"location":"sets/#flat-map","title":"Flat map","text":"<p>This method allows to generate a <code>Set</code> configured from a randomly generated value from another <code>Set</code>.</p> <p>In most cases you'll want to use the <code>Set::composite()</code>. This method will be useful for advanced cases.</p> <p>One example is the ability to randomly generate <code>Set</code>s with associated data. Let's say you want to randomly generate strings defining types (<code>int</code>, <code>string</code>, etc...) with an associated <code>Set</code> to generate values of this type in order to build an imaginary <code>Type</code> class:</p> <pre><code>use Innmind\\BlackBox\\{\n    Set,\n    Set\\Seed,\n};\n\n$pairs = Set::of(\n    ['int', Set::integers()],\n    ['string', Set::strings()],\n    ['float', Set::realNumbers()],\n    ['bool', Set::of(true, false)],\n    // etc...\n);\n\n$types = $pairs-&gt;flatMap(static function(Seed $pair) {\n    [$type, $values] = $pair-&gt;unwrap();\n\n    return $values-&gt;map(static fn($value) =&gt; new Type($type, $value));\n});\n</code></pre> <p>The <code>$types</code> <code>Set</code> could generate the values <code>new Type('bool', true)</code>, <code>new Type('bool', false)</code>, <code>new Type('int', 42)</code>, etc...</p> <p>This example is simple enough and could be expressed without the use of <code>flatMap</code>. Like this:</p> <pre><code>use Innmind\\BlackBox\\Set;\n\n$types = Set::either(\n    Set::integers()-&gt;map(static fn($value) =&gt; ['int', $value]),\n    Set::strings()-&gt;map(static fn($value) =&gt; ['string', $value]),\n    Set::realNumbers()-&gt;map(static fn($value) =&gt; ['float', $value]),\n    Set::of(true, false)-&gt;map(static fn($value) =&gt; ['bool', $value]),\n)\n    -&gt;map(static function($pair) {\n        [$type, $value] = $pair;\n\n        return new Type($type, $value);\n    });\n</code></pre> <p>But say that now you want multiple values instead of a single one. With <code>flatMap</code> it's straightforward, unlike with the other approach.</p> <code>flatMap</code>Alternative <pre><code>use Innmind\\BlackBox\\{\n    Set,\n    Set\\Seed,\n};\n\n$pairs = Set::of(\n    ['int', Set::integers()],\n    ['string', Set::strings()],\n    ['float', Set::realNumbers()],\n    ['bool', Set::of(true, false)],\n    // etc...\n);\n\n$types = $pairs-&gt;flatMap(static function(Seed $pair) {\n    [$type, $values] = $pair-&gt;unwrap();\n\n    return Set::sequence($values)-&gt;map(\n        static fn($value) =&gt; new Type($type, $value),\n    );\n});\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\n$types = Set::either(\n    Set::sequence(Set::integers())-&gt;map(static fn($value) =&gt; ['int', $value]),\n    Set::sequence(Set::strings())-&gt;map(static fn($value) =&gt; ['string', $value]),\n    Set::sequence(Set::realNumbers())-&gt;map(static fn($value) =&gt; ['float', $value]),\n    Set::sequence(Set::of(true, false))-&gt;map(static fn($value) =&gt; ['bool', $value]),\n)\n    -&gt;map(static function($pair) {\n        [$type, $value] = $pair;\n\n        return new Type($type, $value);\n    });\n</code></pre> <p>As you can see with <code>flatMap</code> you can locally define what you want without having to change the <code>Set</code> you rely on. Unlike the alternative where you need to change the initial <code>Set</code> and thus impacting any other <code>Set</code> that could depend on it.</p> Shrinking <p>In the examples above the value passed as argument to the <code>flatMap</code> callable can't be shrunk. This is because we call <code>-&gt;unwrap()</code> to acces to the real value behind the <code>Seed</code> object.</p> <p>When the <code>Seed</code> value is unwrapped, BlackBox can no longer track how it's used and thus can no longer shrink it.</p> <p>In the examples above the seeded value can't be shrunk anyway because it comes from user provided values via <code>Set::of()</code>.</p> <p>A simple example to demonstrate the use case is prefixing a <code>string</code> with an <code>int</code>:</p> <pre><code>use Innmind\\BlackBox\\{\n    Set,\n    Set\\Seed,\n};\n\n$set = Set::integers()-&gt;flatMap(\n    static fn(Seed $int) =&gt; Set::strings()-&gt;map(\n        static fn(string $string) =&gt; $int-&gt;map(\n            static fn(int $int) =&gt; $int.$string,\n        ),\n    ),\n);\n</code></pre> <p>This way BlackBox knows every transformations of a seeded value and re-apply then after shrinking it.</p> <p>And you can also compose multiple <code>Seed</code>s via the <code>Seed::flatMap()</code> method.</p> Randomness <p>By default the <code>Set</code> returned by <code>flatMap</code> will produce values with the same seed (the callable argument).</p> <p>If you want a more wide range of seeded values you should call the <code>-&gt;randomize()</code> method after <code>-&gt;flatMap()</code>.</p>"},{"location":"sets/#filter","title":"Filter","text":"<p>To reuse the password example from above. Say that your password needs to contain the character <code>$</code>. You can do:</p> <pre><code>use Innmind\\BlackBox\\Set;\n\n$set = Set::strings()\n    -&gt;filter(static fn(string $string) =&gt; \\str_contains($string, '$'))\n    -&gt;map(static fn(string $string) =&gt; new Password($string));\n</code></pre> <p>Note</p> <p>You can quickly negate a condition by replacing <code>-&gt;filter()</code> by <code>-&gt;exclude()</code>.</p> Warning <p>This is an example. You should not enforce your passwords to have a specific value in it. The strength is based on length. (US and French recommendations)</p>"},{"location":"sets/#nullable","title":"Nullable","text":"<p>If you need a <code>Set</code> to also generate a <code>null</code> value you can simply do:</p> <pre><code>$set = $set-&gt;nullable();\n</code></pre>"},{"location":"sets/#primitives","title":"Primitives","text":""},{"location":"sets/#strings","title":"Strings","text":"With a single characterWith a random lengthUnicodeUnsafe AnyLowercase letterUppercase letterNumberASCIIAlphanumerical <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars();\n</code></pre> <p>This describes any chars that can be returned by the <code>\\chr()</code> function.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars()-&gt;lowercaseLetter();\n</code></pre> <p>This describes the range <code>a..z</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars()-&gt;uppercaseLetter();\n</code></pre> <p>This describes the range <code>A..Z</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars()-&gt;number();\n</code></pre> <p>This describes the range <code>0..9</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars()-&gt;ascii();\n</code></pre> <p>This describes any character that you can typically find on your keyboard.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;chars()-&gt;alphanumerical();\n</code></pre> <p>This describes any character from <code>-&gt;lowercaseLetter()</code>, <code>-&gt;uppercaseLetter()</code> or <code>-&gt;number()</code>.</p> AnyBetweenAt mostAt leastMade of specific characters <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings();\n</code></pre> <p>This describes any string of a length between <code>0</code> and <code>128</code> containing any character from <code>Set::strings()-&gt;chars()</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;between($min, $max);\n</code></pre> <p>This is the same as <code>Set::strings()</code> but you specify the length range.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;atMost($max);\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;atLeast($min);\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;madeOf($set);\n</code></pre> <p>This describes any string made of the characters you specify (ie <code>Set::strings()-&gt;madeOf(Set::strings()-&gt;chars()-&gt;alphanumerical())</code>)</p> <p>You can specify the length range via <code>Set::strings()-&gt;madeOf(Set)-&gt;between(min, max)</code>.</p> CharacterStringsCharacter from a block <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;unicode()-&gt;char();\n</code></pre> <p>This describes any single unicode character.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;unicode();\n</code></pre> <p>This is the same as <code>Se::strings()-&gt;madeOf(Set::strings()-&gt;unicode()-&gt;char())</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;unicode()-&gt;controlCharater();\nSet::strings()-&gt;unicode()-&gt;basicLatin();\nSet::strings()-&gt;unicode()-&gt;spacingModifierLetters();\n// etc...\n</code></pre> <p>This set provides all the unicode blocks as dedicated methods.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;unsafe();\n</code></pre> <p>This describes any string that could break your code. You can use this to test the robustness of your code.</p>"},{"location":"sets/#integers","title":"Integers","text":"AnyBetweenAboveBelowAny except zeroNatural numbersNatural numbers except zero <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers();\n</code></pre> <p>This describes any integer between <code>\\PHP_INT_MIN</code> and <code>\\PHP_INT_MAX</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;between($min, $max);\n</code></pre> <p>This describes any integer between the bounds you specify.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;above($min);\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;below($max);\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;exceptZero();\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;naturalNumbers();\n</code></pre> <p>This is the same as <code>Set::integers()-&gt;above(0)</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()-&gt;naturalNumbersExceptZero();\n</code></pre> <p>This is the same as <code>Set::integers()-&gt;above(1)</code>.</p> <p>The bounds are included in the values that can be generated</p>"},{"location":"sets/#real-numbers","title":"Real numbers","text":"AnyBetweenAboveBelow <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::realNumbers();\n</code></pre> <p>This describes any float between <code>\\PHP_INT_MIN</code> and <code>\\PHP_INT_MAX</code>.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::realNumbers()-&gt;between($min, $max);\n</code></pre> <p>This describes any float between the bounds you specify.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::realNumbers()-&gt;above($min);\n</code></pre> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::realNumbers()-&gt;below($max);\n</code></pre> <p>The bounds are included in the values that can be generated</p>"},{"location":"sets/#type","title":"Type","text":"<pre><code>use Innmind\\BlackBox\\Set;\n\nSet::type();\n</code></pre> <p>This describes any type that is supported by PHP. This is useful to prove a code doesn't depend on the type of its arguments.</p>"},{"location":"sets/#user-defined-values","title":"User defined values","text":""},{"location":"sets/#elements","title":"Elements","text":"<pre><code>use Innmind\\BlackBox\\Set;\n\nSet::of(...$values);\n</code></pre> <p>This describes all the values that you put in (ie <code>Set::of(true, false)</code> to describe booleans).</p>"},{"location":"sets/#from-a-generator","title":"From a generator","text":"<pre><code>use Innmind\\BlackBox\\Set;\n\nSet::generator(static function() {\n    yield from $values;\n});\n</code></pre> <p>This describes values that you will provide via a <code>Generator</code>.</p>"},{"location":"sets/#higher-order-sets","title":"Higher order <code>Set</code>s","text":""},{"location":"sets/#composite","title":"Composite","text":"<p>This <code>Set</code> allows to aggregate multiple values to a new one. Let's say you have a <code>User</code> class, you could desribe it via:</p> <pre><code>Set::compose(\n    static fn(string $firstname, string $lastname) =&gt; new User(\n        $firstname,\n        $lastname,\n    ),\n    Set::strings()-&gt;atLeast(1),\n    Set::strings()-&gt;atLeast(1),\n);\n</code></pre> <p>Any additionnal <code>Set</code> provided will give access to a new argument to the callable.</p>"},{"location":"sets/#either","title":"Either","text":"<p>You can think of this <code>Set</code> as an OR.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::either(Set::integers(), Set::strings());\n</code></pre> <p>This describes any integer or string.</p>"},{"location":"sets/#sequence","title":"Sequence","text":"<p><code>Set::sequence(Set)</code> describes a list (an array of consecutive values) of values of the given <code>Set</code> type.</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::sequence(Set::integers());\n</code></pre> <p>This describes any list of integers.</p> <p>By default the list contains between <code>0</code> and <code>100</code> elements, you can change this via <code>Set::sequence(Set)-&gt;between(min, max)</code>, <code>-&gt;atLeast()</code> or <code>-&gt;atMost()</code>.</p> <p>The bounds are included.</p>"},{"location":"sets/#tuple","title":"Tuple","text":"<p>This is a special case of <code>Composite</code>. Both examples does the same thing.</p> TupleComposite <pre><code>Set::tuple(\n    Set::integers(),\n    Set::integers(),\n)\n</code></pre> <pre><code>Set::compose(\n    static fn(int $a, int $b) =&gt; [$a, $b],\n    Set::integers(),\n    Set::integers(),\n)\n</code></pre>"},{"location":"sets/#call","title":"Call","text":"<pre><code>Set::call(static function() {\n    return $someValue;\n})\n</code></pre> <p>This set is useful when building the Model to tests via properties. If BlackBox shrinks properties it will call the provided callable at each shrinking step. This allows to get rid of any state inside your Model between each run.</p>"},{"location":"sets/#specific-types","title":"Specific types","text":""},{"location":"sets/#email","title":"Email","text":"<pre><code>use Innmind\\BlackBox\\Set;\n\nSet::email();\n</code></pre> <p>This describes any valid email string.</p>"},{"location":"sets/#uuid","title":"Uuid","text":"<p><pre><code>use Innmind\\BlackBox\\Set;\n\nSet::uuid();\n</code></pre> This describes any valid UUID.</p>"},{"location":"assert/","title":"Assert","text":"<p>The <code>Innmind\\BlackBox\\Runner\\Assert</code> object is the only way to make assertions in your tests/proofs/properties.</p> <p>This object is always passed as an argument where you should apply assertions. If you don't have access to it, then you're doing something wrong.</p> <p>The following chapters will guide you through all the assertions you can use.</p> <p>The base assertions are:</p> SameNot sameEqualsNot equalsForce a failure <pre><code>static function(Assert $assert) {\n    $assert-&gt;same($expected, $someValue, 'Optional error message');\n    // or\n    $assert\n        -&gt;expected($expected)\n        -&gt;same($someValue, 'Optional error message');\n}\n</code></pre> <p>Think <code>===</code>.</p> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;expected($expected)\n        -&gt;not()\n        -&gt;same($someValue, 'Optional error message');\n}\n</code></pre> <p>Think <code>!==</code>.</p> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;expected($expected)\n        -&gt;equals($someValue, 'Optional error message');\n}\n</code></pre> <p>Think <code>==</code>.</p> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;expected($expected)\n        -&gt;not()\n        -&gt;equals($someValue, 'Optional error message');\n}\n</code></pre> <p>Think <code>!=</code>.</p> <pre><code>static function(Assert $assert) {\n    $assert-&gt;fail('Error message');\n}\n</code></pre> <p>This can be useful when dealing with exceptions.</p>"},{"location":"assert/exceptions/","title":"Exceptions","text":"Must throwMust not throw <pre><code>static function(Assert $assert) {\n    $assert-&gt;throws(\n        static function() {\n            // execute some code that must throw an exception\n        },\n        $optionalExceptionClass,\n        'Optional error message',\n    );\n}\n</code></pre> <p>If the code throws an exception but it's not an instance of <code>$optionalExceptionClass</code> then the assertion fails.</p> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;not()\n        -&gt;throws(\n            static function() {\n                // execute some code that must not throw an exception\n            },\n            'Optional error message',\n        );\n}\n</code></pre>"},{"location":"assert/memory/","title":"Memory","text":"<p>In order for these assertions to work properly you need to:</p> <ul> <li>add <code>declare(ticks = 1);</code> at the top of file where you call the assertion</li> <li>the callable cannot use the anonymous function short notation</li> </ul> Example blackbox.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\ndeclare(ticks = 1);\n\nrequire 'path/to/vendor/autoload.php';\n\nuse Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield test(\n            'Some memory test',\n            static function(Assert $assert) {\n                $assert\n                    -&gt;memory(static function() {\n                        // your code here\n                    })\n                    -&gt;inLessThan()\n                    -&gt;megaBytes(42);\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> In less than x BytesIn less than x KiloBytesIn less than x MegaBytesIn more than x BytesIn more than x KiloBytesIn more than x MegaBytes <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inLessThan()\n        -&gt;bytes($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inLessThan()\n        -&gt;kiloBytes($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inLessThan()\n        -&gt;megaBytes($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inMoreThan()\n        -&gt;bytes($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inMoreThan()\n        -&gt;kiloBytes($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;memory(static function() {\n            // execute your code here\n        })\n        -&gt;inMoreThan()\n        -&gt;megaBytes($number, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/objects/","title":"Objects","text":"Is an objectIs an instance ofIsn't an instance of <pre><code>static function(Assert $assert) {\n    $assert-&gt;object($someValue);\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;object($someValue)\n        -&gt;instance($someClass, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;object($someValue)\n        -&gt;not()\n        -&gt;instance($someClass, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/own/","title":"Write your own","text":""},{"location":"assert/own/#stateless","title":"Stateless","text":"<p>A simple example would be to assert a string is a valid uuid.</p> IsUuid.php<pre><code>final class IsUuid\n{\n    public function __construct(\n        private mixed $value\n    ) {}\n\n    public function __invoke(Assert $assert): void\n    {\n        $assert\n            -&gt;string($this-&gt;value)\n            -&gt;matches(\n                '/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-[a-f0-9]{12}$/',\n                'Value is not a uuid',\n            );\n    }\n}\n</code></pre> <p>You can now use this assertion everywhere like this:</p> <pre><code>static function(Assert $assert) {\n    $assert-&gt;matches(new IsUuid($someValue));\n}\n</code></pre>"},{"location":"assert/own/#stateful","title":"Stateful","text":"<p>In some cases you want to carry a state when asserting values. This is usually the case when testing an API.</p> <p>The approach is to wrap the <code>Assert</code> object in an object of your own.</p> <p>Let's say you want to make HTTP requests and sometimes you want to impersonate them.</p> Requests.php<pre><code>use Innmind\\BlackBox\\Runner\\Assert;\n\nfinal class Requests\n{\n    public function __construct(\n        private Assert $assert,\n        private ?string $bearer = null,\n    ) {}\n\n    public function responds(string $url): self\n    {\n        $response = somehowDoAnHTTPCallTo($url, $this-&gt;bearer);\n\n        $this-&gt;assert-&gt;same(200, $response-&gt;code());\n\n        return $this;\n    }\n\n    /**\n     * @param callable(self): void $action\n     */\n    public function impersonate(\n        string $bearer,\n        callable $action,\n    ): self {\n        $action(new self($this-&gt;assert, $bearer));\n\n        return $this;\n    }\n}\n</code></pre> <p>Now you can do:</p> <pre><code>static function(Assert $assert) {\n    $requests = new Requests($assert);\n\n    $requests\n        -&gt;responds('https://github.com')\n        -&gt;impersonate(\n            'some Authorization bearer',\n            static fn(Requests $requests) =&gt; $requests-&gt;responds(\n                'https://github.com/settings/profile',\n            ),\n        )\n        -&gt;responds('https://google.com');\n}\n</code></pre> <p>Calls to <code>responds</code> on line <code>5</code> and <code>12</code> do not use a bearer while the one on line <code>8</code> does.</p>"},{"location":"assert/primitives/","title":"Primitives","text":""},{"location":"assert/primitives/#null","title":"Null","text":"Is nullIs not null <pre><code>static function(Assert $assert) {\n    $assert-&gt;null($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;not()\n        -&gt;null($someValue, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/primitives/#booleans","title":"Booleans","text":"True or FalseTrueFalseNeither True nor FalseNot TrueNot False <pre><code>static function(Assert $assert) {\n    $assert-&gt;bool($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;true($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;false($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;not()-&gt;bool($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;not()-&gt;true($someValue, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;not()-&gt;false($someValue, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/primitives/#resource","title":"Resource","text":"<pre><code>static function(Assert $assert) {\n    $assert-&gt;resource($someValue);\n}\n</code></pre> <p><code>resource</code>s are values return by <code>fopen</code> functions and such.</p>"},{"location":"assert/primitives/#numbers","title":"Numbers","text":"Any numberIs an integerIs a floatGreater thanGreater than or equalLess thanLess than or equal <pre><code>static function(Assert $assert) {\n    $assert-&gt;number($someValue);\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;int('Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;float('Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;greaterThan($someIntOrFloat, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;greaterThanOrEqual($someIntOrFloat, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;lessThan($someIntOrFloat, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;number($someValue)\n        -&gt;lessThanOrEqual($someIntOrFloat, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/primitives/#strings","title":"Strings","text":"Any stringIs emptyContains a valueMatches a regexStarts withEnds with <pre><code>static function(Assert $assert) {\n    $assert-&gt;string($someValue);\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($someValue)\n        -&gt;empty('Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($haystack)\n        -&gt;contains($needle, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($someValue)\n        -&gt;matches($regex, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($someValue)\n        -&gt;startsWith($prefix, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($someValue)\n        -&gt;endsWith($suffix, 'Optional error message');\n}\n</code></pre> <p>You can add a call to <code>-&gt;not()</code> after <code>-&gt;string()</code> to inverse the following assertion.</p> <p>You can chain multiple assertions on the same string like this:</p> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;string($someValue)\n        -&gt;startsWith($prefix, 'Optional error message')\n        -&gt;endsWith($suffix, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/primitives/#arrays","title":"Arrays","text":"Is an arrayHas a keyDoesn't have a keyContains a valueDoesn't contain a valueCountDoesn't have count <pre><code>static function(Assert $assert) {\n    $assert-&gt;array($someValue);\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;array($someValue)\n        -&gt;hasKey($intOrString, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;array($someValue)\n        -&gt;not()\n        -&gt;hasKey($intOrString, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;array($array)\n        -&gt;contains($value, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;array($array)\n        -&gt;not()\n        -&gt;contains($value, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert-&gt;count($count, $array, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;not()\n        -&gt;count($count, $array, 'Optional error message');\n}\n</code></pre>"},{"location":"assert/time/","title":"Time","text":"In less than x millisecondsIn less than x secondsIn more than x millisecondsIn more than x seconds <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;time(static function() {\n            // execute your code here\n        })\n        -&gt;inLessThan()\n        -&gt;milliseconds($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;time(static function() {\n            // execute your code here\n        })\n        -&gt;inLessThan()\n        -&gt;seconds($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;time(static function() {\n            // execute your code here\n        })\n        -&gt;inMoreThan()\n        -&gt;milliseconds($number, 'Optional error message');\n}\n</code></pre> <pre><code>static function(Assert $assert) {\n    $assert\n        -&gt;time(static function() {\n            // execute your code here\n        })\n        -&gt;inMoreThan()\n        -&gt;seconds($number, 'Optional error message');\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>composer require --dev innmind/black-box\n</code></pre>"},{"location":"getting-started/#setup","title":"Setup","text":"blackbox.php<pre><code>&lt;?php\ndeclare(strict_types = 1);\n\nrequire 'path/to/vendor/autoload.php';\n\nuse Innmind\\BlackBox\\Application;\n\nApplication::new([]) #(1)\n    -&gt;tryToProve(static function(): \\Generator {\n        // tests and proofs go here\n    })\n    -&gt;exit();\n</code></pre> <ol> <li>You'll learn in a later chapter what this array is. For now leave it like this.</li> </ol> <p>The function passed to <code>tryToProve</code> must return a <code>Generator</code>. We'll see in the next chapters how to describe tests and proofs.</p> <p>To execute your suite, run <code>php blackbox.php</code> in your terminal.</p>"},{"location":"getting-started/proof/","title":"First proof","text":"<p>Let's reuse the previous <code>add</code> example. As described in the preface a proof is a generalization of a test.</p> <p>But before let's rewrite the previous test with the proof syntax:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield proof(\n            'Add is commutative',\n            given(\n                Set::of(1),\n                Set::of(2),\n            ),\n            static function(Assert $assert, int $a, int $b): void {\n                $assert-&gt;same(\n                    3,\n                    add($a, $b),\n                );\n                $assert-&gt;same(\n                    3,\n                    add($b, $a),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>This behaves exactly as the test one. The hardcoded values <code>1</code> and <code>2</code> are now declared in hardcoded <code>Set</code>s. Every <code>Set</code> passed to the <code>given</code> function adds an argument to the function passed to <code>proof</code>. When it runs BlackBox randomly peaks a value in each <code>Set</code>. In this case it always peaks <code>1</code> and <code>2</code>. This means <code>$a</code> is always <code>1</code> and <code>$b</code> always <code>2</code>.</p> <p>BlackBox by default runs a proof <code>100</code> times.</p> Tip <p>You can change the number of scenarii run for each proof like this:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;scenariiPerProof(10)\n    -&gt;tryToProve(static function(): \\Generator {\n        yield proof(\n            'Add is commutative',\n            given(\n                Set::of(1),\n                Set::of(2),\n            ),\n            static function(Assert $assert, int $a, int $b): void {\n                $assert-&gt;same(\n                    3,\n                    add($a, $b),\n                );\n                $assert-&gt;same(\n                    3,\n                    add($b, $a),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>Of course when the values are harcoded it's pointless to run the same proof multiple times.</p> <p>Let's generalize our proof:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield proof(\n            'Add is commutative',\n            given(\n                Set::integers(),\n                Set::integers(),\n            ),\n            static function(Assert $assert, int $a, int $b): void {\n                $assert-&gt;same(\n                    add($a, $b),\n                    add($b, $a),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>Now <code>$a</code> or <code>$b</code> can be any integer between <code>PHP_INT_MIN</code> and <code>PHP_INT_MAX</code>.</p> <p>Because we don't know the concrete input values we can no longer hardcode the expected output. We can only rely on the function we try to test. That's why we can only test behaviour and not assume any implementation detail.</p> <p>Hence the name BlackBox!</p> <p>When run this would produce this output:</p> <p></p>"},{"location":"getting-started/property/","title":"First property","text":"<p>A property is a proof expressed as object. The previous proof becomes:</p> AddIsCommutative.php<pre><code>use Innmind\\BlackBox\\{\n    Property,\n    Set,\n    Runner\\Assert,\n};\n\n/**\n * @implements Property&lt;Add&gt;\n */\nfinal class AddIsCommutative implements Property\n{\n    private function __construct(\n        private int $a,\n        private int $b,\n    ) {}\n\n    /**\n     * @return Set&lt;self&gt;\n     */\n    public static function any(): Set\n    {\n        return Set::compose(\n            static fn(int $a, int $b) =&gt; new self($a, $b),\n            Set::integers(),\n            Set::integers(),\n        );\n    }\n\n    public function applicableTo(object $add): bool\n    {\n        return true; #(1)\n    }\n\n    public function ensureHeldBy(Assert $assert, object $add): object\n    {\n        $assert-&gt;same(\n            $add($this-&gt;a, $this-&gt;b),\n            $add($this-&gt;b, $this-&gt;a),\n        );\n\n        return $add;\n    }\n}\n</code></pre> <ol> <li>This allows you to not run <code>ensureHeldBy</code> based on <code>$this-&gt;a</code> or <code>$this-&gt;b</code>.</li> </ol> <p>As described in the preface a property applies to objects. This means that you must replace your <code>add</code> function by an <code>Add</code> class with the <code>__invoke</code> method.</p> <p><code>@implements Property&lt;Add&gt;</code> tells Psalm that the <code>$add</code> argument of <code>applicableTo</code> and <code>ensureHeldBy</code> is an instance of <code>Add</code>.</p> <p>You can run this property like this:</p> ExplicitShortcut blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        $add = new Add;\n\n        yield proof(\n            'Add is commutative',\n            given(\n                AddIsCommutative::any()-&gt;filter(\n                    static fn($property) =&gt; $property-&gt;applicableTo($add),\n                ),\n            ),\n            static function(\n                Assert $assert,\n                AddIsCommutative $property\n            ) use ($add): void {\n                $property-&gt;ensureHeldBy($assert, $add);\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> Note <p>Note that since you use a <code>Generator</code> you can setup a test/proof/property by executing any PHP code before yielding them.</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield property(\n            AddIsCommutative::class,\n            Set::of(new Add),\n        );\n    })\n    -&gt;exit();\n</code></pre> Note <p>This shortcut shows that the Model being tested can be generated via <code>Set</code>s. You can randomize the initial state of a Model this way.</p> <p>As said before properties come in groups. To fully prove the behaviour of <code>Add</code> there's 2 more properties required:</p> <ul> <li><code>AddIsCumulative</code></li> <li><code>ZeroIsAnIdentityValue</code></li> </ul> <p>To run all possible scenarii you would write:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n    Set,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield properties(\n            'Add properties',\n            Set\\Properties::any(\n                AddIsCommutative::any(),\n                AddIsCumulative::any(),\n                ZeroIsAnIdentityValue::any(),\n            ),\n            Set::of(new Add),\n        );\n\n        yield property(\n            AddIsCommutative::class,\n            Set::of(new Add),\n        );\n\n        yield property(\n            AddIsCumulative::class,\n            Set::of(new Add),\n        );\n\n        yield property(\n            ZeroIsAnIdentityValue::class,\n            Set::of(new Add),\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>With this you run each property a <code>100</code> times and a <code>100</code> combinations of them being applied successively on the same <code>Add</code> instance.</p> <p>When run, if your <code>Add</code> implementation is correct, it should output:</p> <p></p>"},{"location":"getting-started/test/","title":"First test","text":"<p>Let's reuse the <code>add</code> example from the preface.</p> <p>This function doesn't exist. For the sake of learning you should try to implement it. It will show you how BlackBox can help you fix your implementation.</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield test(\n            'Add is commutative',\n            static function(Assert $assert): void {\n                $assert-&gt;same(\n                    3,\n                    add(1, 2),\n                );\n                $assert-&gt;same(\n                    3,\n                    add(2, 1),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <p>When run this would produce this output:</p> <p></p> <p>Here we <code>yield</code> only one test but you can add as many as you want.</p> <p>You can head to the Assert chapter to learn the various assertions you can use.</p> Tip <p>This example uses the global function <code>test</code>. This works fine. However if you're not at ease you can use namespaced functions like this:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\nuse function Innmind\\BlackBox\\Runner\\test;\n\nApplication::new([])\n    -&gt;disableGlobalFunctions()\n    -&gt;tryToProve(static function(): \\Generator {\n        yield test(\n            'Add is commutative',\n            static function(Assert $assert): void {\n                $assert-&gt;same(\n                    3,\n                    add(1, 2),\n                );\n                $assert-&gt;same(\n                    3,\n                    add(2, 1),\n                );\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre>"},{"location":"internals/","title":"Internals","text":"<p>This section documents some implementation details. This is mainly to transcribe some complex parts of this package.</p>"},{"location":"internals/set-composition/","title":"<code>Set</code> composition","text":"<p>It's possible to compose <code>Set</code>s via the <code>flatMap</code> method. This allows to randomly configure other <code>Set</code>s.</p> <p>One of the main features of <code>Set</code>s is that they can shrink the generated values. This helps find the minimum values that make a test fail.</p> <p>But in the case of the use of <code>Set::flatMap()</code> the value generated to configure another <code>Set</code> escape the control of the parent <code>Set</code>.</p> <p>In order for this value to still be shrunk, BlackBox needs to track every use of it. To achieve this the value is wrapped in a <code>Seed</code> monad. This monad records every transformation (the callables passed to <code>map</code> and <code>flatMap</code>) and apply them when unwrapping the value. This way we can shrink the initial value and then re-apply the transformations.</p> <p>If a user calls <code>Seed::unwrap()</code> to directly manipulate the value then BlackBox can no longer shrink this value.</p> <p>While this design allows to maintain every feature across all possible compositions it introduces a complexity problem in the shrinking design.</p>"},{"location":"internals/shrinking/","title":"Shrinking","text":""},{"location":"internals/shrinking/#description","title":"Description","text":"<p>Each generated <code>Value</code> can be shrunk to 2 new values. These are named <code>a</code> and <code>b</code> and wrapped in a <code>Dichotomy</code>.</p> <p>This allows to take a different route when a shrunk value makes a test pass.</p> <p>Usually the <code>a</code> strategy is the more aggressive shrinking strategy to try to find the smallest value as fast as possible. And <code>b</code> is the more fine grained one, but will take longer.</p> <p>The difficult part of the shrinking mechanism is that values can be mapped/composed to new ones and must adhere to a predicate. And each low level shrunk value must be mapped/composed back and still adhere to the predicate.</p> <p>To keep the shrinkers as simple as possible the mapping and predicates are hidden from them.</p> <p>To do this a <code>Value</code> will always keep the original value, all the transformations steps (aka mapping) and the predicate it must adhere to. Then when a shrinker applies a shrinking strategy to a <code>Value</code>, the value can re-apply the transformations to the shrunk value and make sure the new value adheres to the predicate.</p>"},{"location":"internals/shrinking/#sequence","title":"<code>Sequence</code>","text":"<pre><code>graph TB\n    Array --&gt;|Next| RecursiveHalf{Either}\n    RecursiveHalf --&gt;|a| RemoveHalf\n    RecursiveHalf --&gt;|b| RemoveTail\n    RemoveHalf --&gt;|Next| RecursiveHalf\n    RemoveTail --&gt;|Next| RecursiveTail{Either}\n    RecursiveTail --&gt;|a| RemoveTail\n    RecursiveTail --&gt;|b| RemoveHead\n    RemoveHead --&gt;|Next| RecursiveHead{Either}\n    RecursiveHead --&gt;|a| RemoveHead\n    RecursiveHead --&gt;|b| RemoveNth\n    RemoveNth --&gt;|Next| RecursiveNth{Either}\n    RecursiveNth --&gt;|\"a(n)\"| RemoveNth\n    RecursiveNth --&gt;|\"b(n+1)\"| RemoveNth\n    RemoveNth --&gt;|When n overflows| ShrinkANth[Shrink nth element with strategy A]\n    ShrinkANth --&gt;|Next| RecursiveNthShrink{Either}\n    RecursiveNthShrink --&gt;|\"a(n)\"| ShrinkANth\n    RecursiveNthShrink --&gt;|\"b(n+1)\"| ShrinkANth\n    ShrinkANth --&gt;|When n overflows| ShrinkBNth[Shrink nth element with strategy B]\n    ShrinkBNth --&gt;|Next| RecursiveNthShrink\n    ShrinkBNth --&gt;|When no longer shrinkable| Identity</code></pre> <p>This design makes sure all elements are shrunk to their minimum values. It's assured when shrinking elements of the <code>array</code> with their <code>a</code> or <code>b</code> strategy. When we apply a strategy makes the test pass we try to shrink the next available value in the array. This privileges first shrinking values that do not affect the test.</p> <p>This strategy means the values that affect the failing test are shrunk last. So it will take more shrinking steps to find the minimum values that make a test fail.</p>"},{"location":"internals/shrinking/#composite","title":"<code>Composite</code>","text":"<pre><code>graph TB\n    Composite --&gt;|Next| RecursiveNthShrink{Either}\n    RecursiveNthShrink --&gt;|\"a(n)\"| ShrinkANth\n    RecursiveNthShrink --&gt;|\"b(n+1)\"| ShrinkANth\n    ShrinkANth --&gt;|When n overflows| ShrinkBNth[Shrink nth element with strategy B]\n    ShrinkBNth --&gt;|Next| RecursiveNthShrink\n    ShrinkBNth --&gt;|When no longer shrinkable| Identity</code></pre> <p>This design is identical to the <code>Sequence</code> one except it doesn't need to remove elements from the composite. It only shrinks elements of the composite.</p>"},{"location":"internals/shrinking/#seeded-values","title":"<code>Seed</code>ed values","text":"<p>The complexity of seeded values lies with the filtering of these values when shrinking.</p> <p>Let's take a simple example:</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::strings()-&gt;filter(static fn(string $string) =&gt; $string !== '');\n</code></pre> <p>The <code>Set</code> can apply this filter and not yield any empty string. And for any yielded ones if can access the predicate when shrinking the strings in order to not create <code>Dichotomy</code>s with invalid strings.</p> <p>The problem with seeded values can be expressed with this example:</p> <pre><code>use Innmind\\BlackBox\\Set;\n\nSet::integers()\n    -&gt;flatMap(\n        static fn(Set\\Seed $int) =&gt; Set::strings()-&gt;map(\n            static fn(string $string) =&gt; $int-&gt;map(\n                static fn(int $int) =&gt; $int.$string,\n            ),\n        ),\n    )\n    -&gt;filter(static fn(string $string) =&gt; $string !== '0');\n</code></pre> <p>Here when the <code>filter</code> is applied it abstracts that the string is seeded with a leading <code>int</code>. But in the implementation it can't know where the seed comes from. So it can't affect the way the <code>int</code> could be shrunk.</p> <p>The problem here is that the <code>Dichotomy</code> attached to any <code>Value</code> is statically defined when yielding it.</p> <p>To still correctly filter out seeded values the predicate is attached to the <code>Value</code> object and is check on both values generated by a <code>Dichotomy</code> to make sure both are acceptable. If not both are then it prevents shrinking the seed.</p> <p>This design prevents shrinking to the minimum values in the case only one of the shrunk values is acceptable.</p> <p>A research should be conducted to improve the shrinking system to fix this shortcoming of seeded values.</p>"},{"location":"organization/","title":"Organization","text":"<p>So far all tests/proofs/properties have been declared in the <code>blackbox.php</code> file. This is fine for examples. But in a real project with hundreds of them this is not manageable.</p> <p>Since it uses a <code>Generator</code> you can easily split them into multiple files:</p> BlackBoxFile1File2Etc... blackbox.php<pre><code>use Innmind\\BlackBox\\Application;\n\nApplication::new([])\n    -&gt;tryToProve(static function(): \\Generator {\n        yield from (require 'proofs/file1.php')();\n        yield from (require 'proofs/file2.php')();\n        yield from (require 'proofs/etc.php')();\n    })\n    -&gt;exit();\n</code></pre> proofs/file1.php<pre><code>use Innmind\\BlackBox\\{\n    Runner\\Assert,\n    Set,\n};\n\nreturn static function(): \\Generator {\n    yield proof(\n        'Some proof',\n        given(Set\\Integers::any()),\n        static function(Assert $assert, int $value) {\n            // your code here\n        },\n    );\n};\n</code></pre> proofs/file2.php<pre><code>use Innmind\\BlackBox\\{\n    Runner\\Assert,\n    Set,\n};\n\nreturn static function(): \\Generator {\n    yield proof(\n        'Some proof',\n        given(Set\\Strings::any()),\n        static function(Assert $assert, int $value) {\n            // your code here\n        },\n    );\n};\n</code></pre> proofs/etc.php<pre><code>use Innmind\\BlackBox\\{\n    Runner\\Assert,\n    Set,\n};\n\nreturn static function(): \\Generator {\n    yield test(\n        'Some proof',\n        static function(Assert $assert) {\n            // your code here\n        },\n    );\n};\n</code></pre> <p>This way you can enforce the order in which the files are loaded. However it becomes tedious to modify <code>blackbox.php</code> each time you add a file in <code>proofs/</code>.</p> <p>Instead you can load all files like this:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Load,\n};\n\nApplication::new([])\n    -&gt;tryToProve(Load::everythingIn('proofs/'))\n    -&gt;exit();\n</code></pre>"},{"location":"organization/tags/","title":"Tags","text":"<p>Sometimes you may want to only run a subset of your tests/proofs/properties. The best case is when you're creating new ones. You'll probably run them many times until you get them right.</p> <p>You can do this with tags. Tags are defined by any <code>enum</code>. By default you have access to:</p> <pre><code>namespace Innmind\\BlackBox;\n\nenum Tag\n{\n    case windows;\n    case linux;\n    case macOS;\n    case positive;\n    case negative;\n    case wip;\n    case ci;\n    case local;\n}\n</code></pre> <p>To use them:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Tag,\n    Runner\\Assert,\n};\n\nApplication::new($argv) #(1)\n    -&gt;tryToProve(static function(): \\Generator {\n        yield test(\n            'WIP test',\n            static function(Assert $assert) {\n                // your code here\n            },\n        )-&gt;tag(Tag::wip);\n\n        yield test(\n            'Another test',\n            static function(Assert $assert) {\n                // your code here\n            },\n        );\n    })\n    -&gt;exit();\n</code></pre> <ol> <li>The array passed to <code>new</code> is the list of tags to filter on. By using <code>$argv</code> it allows to specify the tags from the command line.</li> </ol> <p>If you run <code>php blackbox.php wip</code> it will run <code>WIP test</code> but not <code>Another test</code>.</p> <p>You can define multiple tags on each test/proofs/properties.</p>"},{"location":"organization/tags/#add-your-own-tags","title":"Add your own tags","text":"<p>The builtin tags may not be enough for your project. You may want to tag them by business logic for example.</p> <p>This takes 2 steps.</p> <p>First create your enum:</p> Business.php<pre><code>enum Business\n{\n    case billing;\n    case shipping;\n    case warehouse;\n\n    public static function of(string $string): ?self\n    {\n        return match ($string) {\n            'billing' =&gt; self::billing,\n            'shipping' =&gt; self::shipping,\n            'warehouse' =&gt; self::warehouse,\n            default =&gt; null,\n        };\n    }\n}\n</code></pre> <p>Then make BlackBox aware of it:</p> blackbox.php<pre><code>use Innmind\\BlackBox\\{\n    Application,\n    Runner\\Assert,\n};\n\nApplication::new($argv)\n    -&gt;parseTagWith(Business::of(...))\n    -&gt;tryToProve(static function(): \\Generator {\n        yield test(\n            'Shipping test',\n            static function(Assert $assert) {\n                // your code here\n            },\n        )-&gt;tag(Business::shipping);\n\n        yield test(\n            'Billing test',\n            static function(Assert $assert) {\n                // your code here\n            },\n        )-&gt;tag(Business::billing);\n    })\n    -&gt;exit();\n</code></pre>"},{"location":"preface/philosophy/","title":"Philosophy","text":"<p>BlackBox is designed around these objectives:</p> <ul> <li>generating tests</li> <li>composition</li> </ul> <p>Generating tests is what Property Based Testing is all about. But BlackBox takes it a step further as not every part of a program can be tested with properties. Sometimes different parts of a program should be tested with the same test.</p> <p>That's why BlackBox uses <code>Generator</code>s to provide tests/proofs. You can generate new ones on the fly. It can handle any number.</p> <p>Composition is a building block to create any data sets. But it also applies to every part of the framework. It doesn't use any global state.</p> <p>This allows the framework to test itself. To be used in other frameworks such as PHPUnit. Or even create functions to generate tests.</p>"},{"location":"preface/terminology/","title":"Terminology","text":""},{"location":"preface/terminology/#test","title":"Test","text":"<p>A test is a name with a function where you call a part of your program with hardcoded inputs and verify the expected output.</p> <p>If you've used other PHP testing frameworks there is nothing new here.</p>"},{"location":"preface/terminology/#set","title":"Set","text":"<p>A Set (1) represents any value that BlackBox can generate. For example <code>Set::integers()-&gt;between(-100, 100)</code> represents all the values from <code>-100</code> to <code>100</code>. You can think of it as <code>range(-100, 100)</code>. Except values are not pre-calculated. BlackBox will peak values randonly in the range.</p> <ol> <li>Described by the <code>Innmind\\BlackBox\\Set</code> class.</li> </ol> <p>Sets can describe primitive values as well as complex object trees.</p>"},{"location":"preface/terminology/#proof","title":"Proof","text":"<p>A proof is like similar to a test except the inputs are not hardcoded. It uses <code>Set</code>s to generate inputs.</p> <p>For example to prove the correctness of the math <code>add</code> (1) function you need to validate it is commutative. With a test you could verify that <code>add(1, 2)</code> returns <code>3</code> and <code>add(2, 1)</code> also returns <code>3</code>. This is easy to understand, but it doesn't make sure it works for every value.</p> <ol> <li>This function doesn't exist.</li> </ol> <p>With a proof you can write:</p> <p>for any integer $a and any other integer $b then add($a, $b) is identical to add($b, $a)</p> <p>Every time you run such proof it will peak new values from the <code>Set</code>s to verify your code.</p> <p>This means that the more you run your proofs the greater the confidence your program is correct.</p> <p>And the more your team grows the more scenarii will be run.</p> <p>Using this technique to prove a function as simple as <code>add</code> is debatable. But the power of this approach is that the framework will try to find edge cases inputs. For <code>add</code> there's not many. But your program certainly has much more.</p> <p>When you only use tests, if the suite is green you think \"everything works\".</p> <p>With proofs, if the suite is green this means \"everything works so far\". It helps keep the mentality that bugs may still be present in your program. It's a virtuous circle as it motivates to write more tests.</p> Abstract <p>BlackBox uses the term proof to emphasize that you are testing behaviours not specific scenarii, but these are NOT formal proofs.</p>"},{"location":"preface/terminology/#property","title":"Property","text":"<p>A property is like a proof except it's represented via an object (1) and tests the behaviour of an object. The object tested is called a Model.</p> <ol> <li>implementing the interface <code>Innmind\\BlackBox\\Property</code></li> </ol> <p>Properties come in groups. The framework generates many list of instances of these properties to make sure the Model behaviour is never broken.</p> <p>For example to prove the correctness of a <code>Stream</code> object (1) you can have the properties:</p> <ol> <li> <p>abstraction on top of a <code>resource</code></p> </li> <li> <p><code>Read</code></p> </li> <li><code>Seek</code></li> </ol> <p>BlackBox would generate the steps <code>[Read, Seek]</code>, <code>[Seek, Read]</code>, <code>[Read, Read, Seek, Read]</code>, etc...</p> Info <p>This has been used in the <code>innmind/stream</code> package. BlackBox found a sequence of properties that would make the stream unusable. The kind of steps that no human would have written.</p> <p>This technique works as well for low level abstraction as for entire programs (such as an HTTP API).</p> <p>If you build packages, you can expose these properties. This allows developers to test their implementation of an interface. This way there sure it behaves at you intended.</p> <p>Innmind uses this approach for packages such as:</p> <ul> <li><code>innmind/filesystem</code> used by <code>innmind/s3</code></li> <li><code>formal/orm</code> to test its different adapters</li> </ul>"},{"location":"preface/terminology/#shrinking","title":"Shrinking","text":"<p>Shrinking is the killer feature of Property Based Testing.</p> <p>Because inputs are random, a failing scenario can be quite complex. Often it's the presence of some characters in a very long string that will make your program break.</p> <p>Finding the problematic value(s) is not always straightforward.</p> <p>When BlackBox finds a failing scenario it will shrink the input values and rerun the proof. It will repeat it until the scenario passes again. It then prints the smallest possible values that make the proof fail.</p> <p>Concretely this means:</p> <ul> <li>for <code>string</code>s it removes characters</li> <li>for <code>integer</code>s it reduces them toward <code>0</code></li> <li>for <code>array</code>s it removes elements and then shrink its values</li> <li>etc...</li> </ul>"}]}